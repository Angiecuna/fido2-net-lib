using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Text.Json;
using System.Text.Json.Serialization;

using Fido2NetLib.Objects;

namespace Fido2NetLib
{
    public sealed class PublicKeyCredentialCreationOptions : Fido2ResponseBase
    {
        /// <summary>
        /// 
        /// This member contains data about the Relying Party responsible for the request.
        /// Its value’s name member is required.
        /// Its value’s id member specifies the relying party identifier with which the credential should be associated.If omitted, its value will be the CredentialsContainer object’s relevant settings object's origin's effective domain.
        /// </summary>
        [JsonPropertyName("rp"), Required]
        public PublicKeyCredentialRpEntity Rp { get; set; }

        /// <summary>
        /// This member contains data about the user account for which the Relying Party is requesting attestation. 
        /// Its value’s name, displayName and id members are required.
        /// </summary>
        [JsonPropertyName("user"), Required]
        public Fido2User User { get; set; }

        /// <summary>
        /// Must be generated by the Server (Relying Party)
        /// </summary>
        [JsonPropertyName("challenge"), Required]
        [JsonConverter(typeof(Base64UrlConverter))]
        public byte[] Challenge { get; set; }

        /// <summary>
        /// This member contains information about the desired properties of the credential to be created. The sequence is ordered from most preferred to least preferred. The platform makes a best-effort to create the most preferred credential that it can.
        /// </summary>
        [JsonPropertyName("pubKeyCredParams"), Required]
        public List<PublicKeyCredentialParameters> PublicKeyCredentialParameters { get; set; }

        /// <summary>
        /// This member specifies a time, in milliseconds, that the caller is willing to wait for the call to complete. This is treated as a hint, and MAY be overridden by the platform.
        /// </summary>
        [JsonPropertyName("timeout")]
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        public long? Timeout { get; set; }

        /// <summary>
        /// This member is intended for use by Relying Parties that wish to limit the creation of multiple credentials for the same account on a single authenticator.The client is requested to return an error if the new credential would be created on an authenticator that also contains one of the credentials enumerated in this parameter.
        /// </summary>
        [JsonPropertyName("excludeCredentials")]
        public List<PublicKeyCredentialDescriptor> ExcludeCredentials { get; set; }
#nullable enable
        /// <summary>
        /// This member is intended for use by Relying Parties that wish to select the appropriate authenticators to participate in the create() operation.
        /// </summary>
        [JsonPropertyName("authenticatorSelection")]
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        public AuthenticatorSelectionCriteria? AuthenticatorSelectionCriteria { get; set; }

        /// <summary>
        /// This member is intended for use by Relying Parties that wish to express their preference for attestation conveyance.The default is none.
        /// </summary>
        [JsonPropertyName("attestation")]
        public AttestationConveyancePreference Attestation { get; set; } = AttestationConveyancePreference.None;

        /// <summary>
        /// This OPTIONAL member contains additional parameters requesting additional processing by the client and authenticator. For example, if transaction confirmation is sought from the user, then the prompt string might be included as an extension.
        /// </summary>
        [JsonPropertyName("extensions")]
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        public AuthenticationExtensionsClientInputs? Extensions { get; set; }
#nullable disable
        public static PublicKeyCredentialCreationOptions Create(Fido2Configuration config, byte[] challenge, Fido2User user, AuthenticatorSelectionCriteria authenticatorSelection, AttestationConveyancePreference attestationConveyancePreference, List<PublicKeyCredentialDescriptor> excludeCredentials, AuthenticationExtensionsClientInputs extensions)
        {
            return new PublicKeyCredentialCreationOptions
            {
                Status = "ok",
                ErrorMessage = string.Empty,
                Challenge = challenge,
                Rp = new PublicKeyCredentialRpEntity(config.ServerDomain, config.ServerName),
                Timeout = config.Timeout,
                User = user,
                PublicKeyCredentialParameters = new List<PublicKeyCredentialParameters>()
                {
                    // Add additional as appropriate
                    // TODO: Make this a configuration parameter with reasonable defaults
                    Ed25519,
                    ES256,
                    RS256,
                    PS256,
                    ES384,
                    RS384,
                    PS384,
                    ES512,
                    RS512,
                    PS512,
                    RS1,
                },
                AuthenticatorSelectionCriteria = authenticatorSelection,
                Attestation = attestationConveyancePreference,
                ExcludeCredentials = excludeCredentials ?? new List<PublicKeyCredentialDescriptor>(),
                Extensions = extensions
            };
        }

        public string ToJson()
        {
            return JsonSerializer.Serialize(this);
        }

        public static PublicKeyCredentialCreationOptions FromJson(string json)
        {
            return JsonSerializer.Deserialize<PublicKeyCredentialCreationOptions>(json);
        }

        private static readonly PublicKeyCredentialParameters ES256   = new(COSE.Algorithm.ES256); // External authenticators support the ES256 algorithm
        private static readonly PublicKeyCredentialParameters ES384   = new(COSE.Algorithm.ES384);
        private static readonly PublicKeyCredentialParameters ES512   = new(COSE.Algorithm.ES512);
        private static readonly PublicKeyCredentialParameters RS256   = new(COSE.Algorithm.RS256); // Supported by windows hello
        private static readonly PublicKeyCredentialParameters RS384   = new(COSE.Algorithm.RS384);
        private static readonly PublicKeyCredentialParameters RS512   = new(COSE.Algorithm.RS512);
        private static readonly PublicKeyCredentialParameters PS256   = new(COSE.Algorithm.PS256);
        private static readonly PublicKeyCredentialParameters PS384   = new(COSE.Algorithm.PS384);
        private static readonly PublicKeyCredentialParameters PS512   = new(COSE.Algorithm.PS512);
        private static readonly PublicKeyCredentialParameters Ed25519 = new(COSE.Algorithm.EdDSA);
        private static readonly PublicKeyCredentialParameters RS1 = new(COSE.Algorithm.RS1);
    }

    public sealed class PublicKeyCredentialParameters
    {
        /// <summary>
        /// Constructs a PublicKeyCredentialParameters instance
        /// </summary>
        [JsonConstructor]
        public PublicKeyCredentialParameters(COSE.Algorithm alg, PublicKeyCredentialType type = PublicKeyCredentialType.PublicKey)
        {
            Type = type;
            Alg = alg;
        }

        /// <summary>
        /// The type member specifies the type of credential to be created.
        /// </summary>
        [JsonPropertyName("type")]
        public PublicKeyCredentialType Type { get; }

        /// <summary>
        /// The alg member specifies the cryptographic signature algorithm with which the newly generated credential will be used, and thus also the type of asymmetric key pair to be generated, e.g., RSA or Elliptic Curve.
        /// </summary>
        [JsonPropertyName("alg")]
        public COSE.Algorithm Alg { get; }
    }

    /// <summary>
    /// https://w3c.github.io/webauthn/#dictionary-rp-credential-params
    /// PublicKeyCredentialRpEntity is used to supply additional Relying Party attributes when creating a new credential.
    /// </summary>
    public class PublicKeyCredentialRpEntity : PublicKeyCredentialEntity
    {
        public PublicKeyCredentialRpEntity(string id, string name = "")
        {
            Id = id;
            Name = name;
        }

        /// <summary>
        /// A unique identifier for the Relying Party entity, which sets the RP ID.
        /// </summary>
        [JsonPropertyName("id")]
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        public string Id { get; set; }
    }

    /// <summary>
    /// WebAuthn Relying Parties may use the AuthenticatorSelectionCriteria dictionary to specify their requirements regarding authenticator attributes.
    /// </summary>
    public class AuthenticatorSelectionCriteria
    {
        /// <summary>
        /// If this member is present, eligible authenticators are filtered to only authenticators attached with the specified §5.4.5 Authenticator Attachment enumeration (enum AuthenticatorAttachment).
        /// </summary>
        [JsonPropertyName("authenticatorAttachment")]
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
        public AuthenticatorAttachment? AuthenticatorAttachment { get; set; }

        /// <summary>
        /// Specifies the extent to which the Relying Party desires to create a client-side discoverable credential. 
        /// For historical reasons the naming retains the deprecated “resident” terminology. 
        /// The value SHOULD be a member of ResidentKeyRequirement but client platforms MUST ignore unknown values, treating an unknown value as if the member does not exist. 
        /// If no value is given then the effective value is required if requireResidentKey is true or discouraged if it is false or absent.
        /// </summary>
        [JsonPropertyName("residentKey")]
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
        public ResidentKeyRequirement? ResidentKey { get; set; }

        /// <summary>
        /// This member describes the Relying Parties' requirements regarding resident credentials. If the parameter is set to true, the authenticator MUST create a client-side-resident public key credential source when creating a public key credential.
        /// </summary>
        [JsonPropertyName("requireResidentKey")]
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        public bool? RequireResidentKey { get; set; }

        /// <summary>
        /// This member describes the Relying Party's requirements regarding user verification for the create() operation. Eligible authenticators are filtered to only those capable of satisfying this requirement.
        /// </summary>
        [JsonPropertyName("userVerification")]
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
        public UserVerificationRequirement UserVerification { get; set; }

        public static AuthenticatorSelectionCriteria Default => new AuthenticatorSelectionCriteria
        {
            AuthenticatorAttachment = null,
            ResidentKey = null,
            RequireResidentKey = false,
            UserVerification = UserVerificationRequirement.Preferred
        };
    }

    public class PublicKeyCredentialEntity
    {
        /// <summary>
        /// A human-palatable name for the entity.
        /// </summary>
        [JsonPropertyName("name"), Required]
        public string Name { get; set; }
    }

    public class PublicKeyCredentialUserEntity : PublicKeyCredentialEntity
    {
        /// <summary>
        /// The user handle of the user account entity. To ensure secure operation, authentication and authorization decisions MUST be made on the basis of this id member, not the displayName nor name members
        /// </summary>
        [JsonPropertyName("id"), Required]
        [JsonConverter(typeof(Base64UrlConverter))]
        public byte[] Id { get; set; }

        /// <summary>
        /// A human-friendly name for the user account, intended only for display. For example, "Alex P. Müller" or "田中 倫". The Relying Party SHOULD let the user choose this, and SHOULD NOT restrict the choice more than necessary.
        /// </summary>
        [JsonPropertyName("displayName"), Required]
        public string DisplayName { get; set; }
    }

    public class Fido2User : PublicKeyCredentialUserEntity
    {
    }
}
